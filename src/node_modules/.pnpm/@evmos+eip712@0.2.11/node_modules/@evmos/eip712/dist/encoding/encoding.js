"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashEIP712 = exports.decodeSignDocToTypedData = void 0;
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const decodeAmino_1 = require("./decodeAmino");
const decodeProtobuf_1 = require("./decodeProtobuf");
function decodeSignDocToTypedData(bytes) {
    let eip712;
    let aminoDecodeErr;
    let protoDecodeErr;
    try {
        eip712 = (0, decodeAmino_1.decodeAminoSignDoc)(bytes);
    }
    catch (e) {
        aminoDecodeErr = e;
    }
    try {
        eip712 = (0, decodeProtobuf_1.decodeProtobufSignDoc)(bytes);
    }
    catch (e) {
        protoDecodeErr = e;
    }
    if (!eip712) {
        throw new Error(`Could not cast bytes to either StdSignDoc or SignDoc:\n
                    Amino: ${aminoDecodeErr === null || aminoDecodeErr === void 0 ? void 0 : aminoDecodeErr.message}\n
                    Protobuf: ${protoDecodeErr === null || protoDecodeErr === void 0 ? void 0 : protoDecodeErr.message}\n`);
    }
    return eip712;
}
exports.decodeSignDocToTypedData = decodeSignDocToTypedData;
function hashEIP712(eip712) {
    try {
        const eip712Domain = eth_sig_util_1.TypedDataUtils.hashStruct('EIP712Domain', eip712.domain, eip712.types, eth_sig_util_1.SignTypedDataVersion.V4);
        const eip712Hash = eth_sig_util_1.TypedDataUtils.hashStruct(eip712.primaryType, eip712.message, eip712.types, eth_sig_util_1.SignTypedDataVersion.V4);
        return {
            domain: eip712Domain,
            message: eip712Hash,
        };
    }
    catch (e) {
        throw new Error(`Could not hash EIP-712 object: ${e}`);
    }
}
exports.hashEIP712 = hashEIP712;
//# sourceMappingURL=encoding.js.map