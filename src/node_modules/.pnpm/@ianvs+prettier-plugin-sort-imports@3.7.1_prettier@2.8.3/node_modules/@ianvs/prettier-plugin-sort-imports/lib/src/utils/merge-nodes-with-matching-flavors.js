"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeNodesWithMatchingImportFlavors = void 0;
var assert_1 = __importDefault(require("assert"));
var constants_1 = require("../constants");
var get_import_flavor_of_node_1 = require("./get-import-flavor-of-node");
function isMergeableFlavor(flavor) {
    return constants_1.mergeableImportFlavors.includes(flavor);
}
/**
 * Builds an object map of import declarations which can be merged together,
 * grouped by whether they are type or value import declarations.
 */
function selectMergeableNodesByImportFlavor(nodes) {
    var _a;
    return nodes.reduce(function (groups, node) {
        var flavor = (0, get_import_flavor_of_node_1.getImportFlavorOfNode)(node);
        if (isMergeableFlavor(flavor)) {
            groups[flavor].push(node);
        }
        return groups;
    }, (_a = {},
        _a[constants_1.importFlavorValue] = [],
        _a[constants_1.importFlavorType] = [],
        _a));
}
/**
 * Returns the "source" (i.e. module name or path) of an import declaration
 *
 * e.g.: `import foo from "./foo";` -- "./foo" is the source.
 */
function selectNodeImportSource(node) {
    return node.source.value;
}
/** e.g. import * as Namespace from "someModule" */
function nodeIsImportNamespaceSpecifier(node) {
    return node.type === 'ImportNamespaceSpecifier';
}
/**
 * Default type or value import
 *
 * e.g.
 * import Default from "someModule"
 * import type Default from "someModule"
 */
function nodeIsImportDefaultSpecifier(node) {
    return node.type === 'ImportDefaultSpecifier';
}
function nodeIsImportSpecifier(node) {
    return node.type === 'ImportSpecifier';
}
function convertImportSpecifierToType(node) {
    (0, assert_1.default)(node.importKind === 'value' || node.importKind === 'type');
    node.importKind = 'type';
}
/** Pushes an `import type` expression into `import { type â€¦}` */
function convertTypeImportToValueImport(node) {
    (0, assert_1.default)(node.importKind === 'type');
    node.importKind = 'value';
    node.specifiers
        .filter(nodeIsImportSpecifier)
        .forEach(convertImportSpecifierToType);
}
/** Return false if the merge will produce an invalid result */
function mergeIsSafe(nodeToKeep, nodeToForget) {
    if (nodeToKeep.specifiers.some(nodeIsImportNamespaceSpecifier) ||
        nodeToForget.specifiers.some(nodeIsImportNamespaceSpecifier)) {
        // An `import * as Foo` namespace specifier cannot be merged
        //   with other import expressions.
        return false;
    }
    if (nodeToKeep.specifiers.some(nodeIsImportDefaultSpecifier) &&
        nodeToForget.specifiers.some(nodeIsImportDefaultSpecifier)) {
        // Two `import Foo from` specifiers cannot be merged trivially.
        // -- Notice: this is *not* import {default as Foo1, default as Foo2} -- that's legal!
        //
        // Future work could convert `import Foo1 from 'a'; import Foo2 from 'a';
        //  into `import {default as Foo1, default as Foo2} from 'a';`
        // But since this runs the risk of making code longer, this won't be in v1.
        return false;
    }
    if (nodeToKeep.importKind === 'type' && nodeToKeep.specifiers.some(nodeIsImportDefaultSpecifier) ||
        nodeToForget.importKind === 'type' && nodeToForget.specifiers.some(nodeIsImportDefaultSpecifier)) {
        // Cannot merge default type imports (.e.g. import type React from 'react')
        return false;
    }
    return true;
}
/**
 * Mutates the modeToKeep, adding the import specifiers and comments from the nodeToForget.
 *
 * @returns (true to delete node | false to keep node)
 */
function mergeNodes(nodeToKeep, nodeToForget) {
    var _a;
    if (!mergeIsSafe(nodeToKeep, nodeToForget)) {
        return false;
    }
    if (nodeToKeep.importKind === 'type' &&
        nodeToForget.importKind === 'value') {
        convertTypeImportToValueImport(nodeToKeep);
    }
    else if (nodeToKeep.importKind === 'value' &&
        nodeToForget.importKind === 'type') {
        convertTypeImportToValueImport(nodeToForget);
    }
    (_a = nodeToKeep.specifiers).push.apply(_a, nodeToForget.specifiers);
    // These mutations don't update the line numbers, and that's crucial for moving things around.
    // To get updated line-numbers you would need to re-parse the code after these changes are rendered!
    nodeToKeep.leadingComments = __spreadArray(__spreadArray([], (nodeToKeep.leadingComments || []), true), (nodeToForget.leadingComments || []), true);
    nodeToKeep.innerComments = __spreadArray(__spreadArray([], (nodeToKeep.innerComments || []), true), (nodeToForget.innerComments || []), true);
    nodeToKeep.trailingComments = __spreadArray(__spreadArray([], (nodeToKeep.trailingComments || []), true), (nodeToForget.trailingComments || []), true);
    return true;
}
/**
 * Modifies context, deleteContext,
 * case A: context has no node for an import source, then it's assigned.
 * case B: context has a node for an import source, then it's merged, and old node is added to deleteContext.
 */
function mutateContextAndMerge(_a) {
    var context = _a.context, nodesToDelete = _a.nodesToDelete, insertableNode = _a.insertableNode;
    var source = selectNodeImportSource(insertableNode);
    if (context[source]) {
        if (mergeNodes(context[source], insertableNode)) {
            nodesToDelete.push(insertableNode);
        }
    }
    else {
        context[source] = insertableNode;
    }
}
/**
 * Accepts an array of nodes from a given chunk, and merges candidates that have a matching import-flavor
 *
 * In other words each group will be merged if they have the same source:
 * - `import type` expressions from the same source
 * - `import Name, {a, b}` from the same source
 *
 * `import type {Foo}` expressions won't be converted into `import {type Foo}` or vice versa
 */
var mergeNodesWithMatchingImportFlavors = function (input, _a) {
    var importOrderCombineTypeAndValueImports = _a.importOrderCombineTypeAndValueImports;
    var nodesToDelete = [];
    var context = {};
    var groups = selectMergeableNodesByImportFlavor(input);
    for (var _i = 0, mergeableImportFlavors_1 = constants_1.mergeableImportFlavors; _i < mergeableImportFlavors_1.length; _i++) {
        var groupKey = mergeableImportFlavors_1[_i];
        if (!importOrderCombineTypeAndValueImports) {
            // Reset in loop to avoid unintended merge across variants
            context = {};
        }
        var group = groups[groupKey];
        for (var _b = 0, group_1 = group; _b < group_1.length; _b++) {
            var insertableNode = group_1[_b];
            mutateContextAndMerge({
                context: context,
                nodesToDelete: nodesToDelete,
                insertableNode: insertableNode,
            });
        }
    }
    return input.filter(function (n) { return !nodesToDelete.includes(n); });
};
exports.mergeNodesWithMatchingImportFlavors = mergeNodesWithMatchingImportFlavors;
