"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSortedNodesByImportOrder = void 0;
var lodash_clone_1 = __importDefault(require("lodash.clone"));
var constants_1 = require("../constants");
var natural_sort_1 = require("../natural-sort");
var get_import_nodes_matched_group_1 = require("./get-import-nodes-matched-group");
var get_sorted_import_specifiers_1 = require("./get-sorted-import-specifiers");
var get_sorted_nodes_group_1 = require("./get-sorted-nodes-group");
/**
 * This function returns the given nodes, sorted in the order as indicated by
 * the importOrder array from the given options.
 * The plugin considers these import nodes as local import declarations.
 * @param nodes A subset of all import nodes that should be sorted.
 * @param options Options to influence the behavior of the sorting algorithm.
 */
var getSortedNodesByImportOrder = function (nodes, options) {
    natural_sort_1.naturalSort.insensitive = options.importOrderCaseInsensitive;
    var importOrder = options.importOrder;
    var importOrderSeparation = options.importOrderSeparation, importOrderSortSpecifiers = options.importOrderSortSpecifiers, importOrderGroupNamespaceSpecifiers = options.importOrderGroupNamespaceSpecifiers, importOrderBuiltinModulesToTop = options.importOrderBuiltinModulesToTop;
    var originalNodes = nodes.map(lodash_clone_1.default);
    var finalNodes = [];
    if (!importOrder.includes(constants_1.THIRD_PARTY_MODULES_SPECIAL_WORD)) {
        importOrder = __spreadArray([constants_1.THIRD_PARTY_MODULES_SPECIAL_WORD], importOrder, true);
    }
    if (importOrderBuiltinModulesToTop) {
        importOrder = __spreadArray([constants_1.BUILTIN_MODULES], importOrder, true);
    }
    var importOrderGroups = importOrder.reduce(function (groups, regexp) {
        var _a;
        // Don't create a new group for explicit import separators
        return isCustomGroupSeparator(regexp)
            ? groups
            : __assign(__assign({}, groups), (_a = {}, _a[regexp] = [], _a));
    }, {});
    var sanitizedImportOrder = importOrder.filter(function (group) {
        return !isCustomGroupSeparator(group) &&
            group !== constants_1.THIRD_PARTY_MODULES_SPECIAL_WORD;
    });
    // Assign import nodes into import order groups
    for (var _i = 0, originalNodes_1 = originalNodes; _i < originalNodes_1.length; _i++) {
        var node = originalNodes_1[_i];
        var matchedGroup = (0, get_import_nodes_matched_group_1.getImportNodesMatchedGroup)(node, sanitizedImportOrder);
        importOrderGroups[matchedGroup].push(node);
    }
    for (var _a = 0, importOrder_1 = importOrder; _a < importOrder_1.length; _a++) {
        var group = importOrder_1[_a];
        // If it's a custom separator, all we need to do is add a newline
        if (isCustomGroupSeparator(group)) {
            var lastNode = finalNodes[finalNodes.length - 1];
            // Avoid empty new line if first group is empty
            if (!lastNode) {
                continue;
            }
            // Don't add multiple newlines
            if (isNodeANewline(lastNode)) {
                continue;
            }
            finalNodes.push(constants_1.newLineNode);
            continue;
        }
        var groupNodes = importOrderGroups[group];
        if (groupNodes.length === 0)
            continue;
        var sortedInsideGroup = (0, get_sorted_nodes_group_1.getSortedNodesGroup)(groupNodes, {
            importOrderGroupNamespaceSpecifiers: importOrderGroupNamespaceSpecifiers,
        });
        // Sort the import specifiers
        if (importOrderSortSpecifiers) {
            sortedInsideGroup.forEach(function (node) {
                return (0, get_sorted_import_specifiers_1.getSortedImportSpecifiers)(node);
            });
        }
        finalNodes.push.apply(finalNodes, sortedInsideGroup);
        if (importOrderSeparation) {
            finalNodes.push(constants_1.newLineNode);
        }
    }
    return finalNodes;
};
exports.getSortedNodesByImportOrder = getSortedNodesByImportOrder;
/**
 * isCustomGroupSeparator checks if the provided pattern is intended to be used
 * as an import separator, rather than an actual group of imports.
 */
function isCustomGroupSeparator(pattern) {
    return pattern.trim() === '';
}
function isNodeANewline(node) {
    return node.type === 'ExpressionStatement';
}
