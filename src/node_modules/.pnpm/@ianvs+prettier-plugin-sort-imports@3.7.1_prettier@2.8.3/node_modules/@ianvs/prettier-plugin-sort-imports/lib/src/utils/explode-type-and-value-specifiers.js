"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.explodeTypeAndValueSpecifiers = void 0;
var types_1 = require("@babel/types");
/**
 * Breaks apart import declarations containing mixed type and value imports into separate declarations.
 *
 * e.g.
 *
 * ```diff
 * - import foo, { bar, type Baz } from './source';
 * + import foo, { bar } from './source';
 * + import type { Baz } from './source';
 * ```
 */
var explodeTypeAndValueSpecifiers = function (nodes) {
    var explodedNodes = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        // We don't need to explode type imports, they won't mix type and value
        if (node.importKind === 'type') {
            explodedNodes.push(node);
            continue;
        }
        // Nothing to do if there's only one specifier
        if (node.specifiers.length <= 1) {
            explodedNodes.push(node);
            continue;
        }
        // @ts-expect-error TS is not refining correctly, but we're checking the type
        var typeImports = node.specifiers.filter(function (i) { return i.type === 'ImportSpecifier' && i.importKind === 'type'; });
        // If we have a mix of type and value imports, we need to 'splode them into two import declarations
        if (typeImports.length) {
            var valueImports = node.specifiers.filter(function (i) {
                return !(i.type === 'ImportSpecifier' && i.importKind === 'type');
            });
            var newValueNode = (0, types_1.importDeclaration)(valueImports, node.source);
            explodedNodes.push(newValueNode);
            // Change the importKind of the specifiers, to avoid `import type {type Foo} from 'foo'`
            typeImports.forEach(function (specifier) { return (specifier.importKind = 'value'); });
            var newTypeNode = (0, types_1.importDeclaration)(typeImports, node.source);
            newTypeNode.importKind = 'type';
            explodedNodes.push(newTypeNode);
            continue;
        }
        // Just a boring old values-only node
        explodedNodes.push(node);
    }
    return explodedNodes;
};
exports.explodeTypeAndValueSpecifiers = explodeTypeAndValueSpecifiers;
