"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImportNodesMatchedGroup = void 0;
var constants_1 = require("../constants");
/**
 * Get the regexp group to keep the import nodes.
 *
 * This comes near the end of processing, after import declaration nodes have been combined or exploded.
 *
 * @param node
 * @param importOrder
 */
var getImportNodesMatchedGroup = function (node, importOrder) {
    var includesTypesSpecialWord = importOrder.some(function (group) {
        return group.includes(constants_1.TYPES_SPECIAL_WORD);
    });
    var groupWithRegExp = importOrder
        .map(function (group) { return ({
        group: group,
        // Strip <TYPES> when creating regexp
        regExp: new RegExp(group.replace(constants_1.TYPES_SPECIAL_WORD, '')),
    }); })
        // Remove explicit bare <TYPES> group, we'll deal with that at the end similar to third party modules
        .filter(function (_a) {
        var group = _a.group;
        return group !== constants_1.TYPES_SPECIAL_WORD;
    });
    for (var _i = 0, groupWithRegExp_1 = groupWithRegExp; _i < groupWithRegExp_1.length; _i++) {
        var _a = groupWithRegExp_1[_i], group = _a.group, regExp = _a.regExp;
        var matched = false;
        // Type imports need to be checked separately
        // Note: this does not include import specifiers, just declarations.
        if (group.includes(constants_1.TYPES_SPECIAL_WORD)) {
            // Since we stripped <TYPES> above, this will have a regexp too, e.g. local types
            matched =
                node.importKind === 'type' &&
                    node.source.value.match(regExp) !== null;
        }
        else {
            // If <TYPES> is being used for any group, and this group doesn't have it, only look for value imports
            matched = includesTypesSpecialWord
                ? node.importKind !== 'type' &&
                    node.source.value.match(regExp) !== null
                : node.source.value.match(regExp) !== null;
        }
        if (matched)
            return group;
    }
    return node.importKind === 'type' && includesTypesSpecialWord
        ? constants_1.TYPES_SPECIAL_WORD
        : constants_1.THIRD_PARTY_MODULES_SPECIAL_WORD;
};
exports.getImportNodesMatchedGroup = getImportNodesMatchedGroup;
