import { Address, TypedData, TypedDataToPrimitiveTypes, TypedDataDomain, ResolvedConfig } from 'abitype';
import { BigNumber, providers, Signer as Signer$1 } from 'ethers';

declare const chainId: {
    readonly mainnet: 1;
    readonly goerli: 5;
    readonly sepolia: 11155111;
    readonly optimism: 10;
    readonly optimismGoerli: 420;
    readonly polygon: 137;
    readonly polygonMumbai: 80001;
    readonly arbitrum: 42161;
    readonly arbitrumGoerli: 421613;
    readonly localhost: 1337;
    readonly hardhat: 31337;
    readonly foundry: 31337;
};
type ChainName = keyof typeof chainId;
declare const mainnet: Chain;
declare const goerli: Chain;
declare const sepolia: Chain;
declare const optimism: Chain;
declare const optimismGoerli: Chain;
declare const polygon: Chain;
declare const polygonMumbai: Chain;
declare const arbitrum: Chain;
declare const arbitrumGoerli: Chain;
declare const localhost: Chain;
declare const hardhat: Chain;
declare const foundry: Chain;
/**
 * Common chains for convenience
 * Should not contain all possible chains
 */
declare const chain: {
    readonly mainnet: Chain;
    readonly goerli: Chain;
    readonly sepolia: Chain;
    readonly optimism: Chain;
    readonly optimismGoerli: Chain;
    readonly polygon: Chain;
    readonly polygonMumbai: Chain;
    readonly arbitrum: Chain;
    readonly arbitrumGoerli: Chain;
    readonly localhost: Chain;
    readonly hardhat: Chain;
    readonly foundry: Chain;
};
declare const allChains: Chain[];
declare const defaultChains: Chain[];
declare const defaultL2Chains: Chain[];

type BlockExplorerName = 'etherscan';
type BlockExplorer = {
    name: string;
    url: string;
};
type EtherscanChains = Extract<ChainName, 'mainnet' | 'goerli' | 'sepolia' | 'optimism' | 'optimismGoerli' | 'polygon' | 'polygonMumbai' | 'arbitrum' | 'arbitrumGoerli'>;
declare const etherscanBlockExplorers: Record<EtherscanChains, BlockExplorer>;

type RpcProviderName = 'alchemy' | 'infura' | 'public';
type AlchemyChains = Extract<ChainName, 'mainnet' | 'goerli' | 'optimism' | 'optimismGoerli' | 'polygon' | 'polygonMumbai' | 'arbitrum' | 'arbitrumGoerli'>;
declare const alchemyRpcUrls: Record<AlchemyChains, string>;
type InfuraChains = Extract<ChainName, 'mainnet' | 'goerli' | 'sepolia' | 'optimism' | 'optimismGoerli' | 'polygon' | 'polygonMumbai' | 'arbitrum' | 'arbitrumGoerli'>;
declare const infuraRpcUrls: Record<InfuraChains, string>;
type PublicChains = Extract<ChainName, 'mainnet' | 'goerli' | 'sepolia' | 'optimism' | 'optimismGoerli' | 'polygon' | 'polygonMumbai' | 'arbitrum' | 'arbitrumGoerli'>;
declare const publicRpcUrls: Record<PublicChains, string>;

declare const units: readonly ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];

declare module 'abitype' {
    interface Config {
        BigIntType: BigNumber;
        IntType: number;
    }
}
declare module 'ethers/lib/utils.js' {
    function getAddress(address: string): Address;
    function isAddress(address: string): address is Address;
    function verifyTypedData<TTypedData extends TypedData, TSchema extends TypedDataToPrimitiveTypes<TTypedData>>(domain: TypedDataDomain, types: TTypedData, value: TSchema[keyof TSchema] extends infer TValue ? {
        [x: string]: any;
    } extends TValue ? Record<string, any> : TValue : never, signature: {
        r: string;
        s?: string;
        _vs?: string;
        recoveryParam?: number;
        v?: number;
    } | ResolvedConfig['BytesType'] | string): string;
}
type Hash = `0x${string}`;
type Chain = {
    /** ID in number form */
    id: number;
    /** Human-readable name */
    name: string;
    /** Internal network name */
    network: string;
    /** Currency used by chain */
    nativeCurrency?: AddEthereumChainParameter['nativeCurrency'];
    /** Collection of RPC endpoints */
    rpcUrls: {
        [key in RpcProviderName]?: string;
    } & {
        [key: string]: string;
        default: string;
    };
    /** Collection of block explorers */
    blockExplorers?: {
        [key in BlockExplorerName]?: BlockExplorer;
    } & {
        [key: string]: BlockExplorer;
        default: BlockExplorer;
    };
    /** ENS registry */
    ens?: {
        address: Address;
    };
    /**
     * Chain [multicall3 contract](https://github.com/mds1/multicall)
     */
    multicall?: {
        address: Address;
        blockCreated: number;
    };
    /** Flag for test networks */
    testnet?: boolean;
};
type ChainProviderFn<TProvider extends Provider = providers.BaseProvider, TWebSocketProvider extends WebSocketProvider = providers.WebSocketProvider, TChain extends Chain = Chain> = (chain: TChain) => {
    chain: TChain;
    provider: () => ProviderWithFallbackConfig<TProvider>;
    webSocketProvider?: () => TWebSocketProvider;
} | null;
type FallbackProviderConfig = Omit<providers.FallbackProviderConfig, 'provider'>;
type ProviderWithFallbackConfig<TProvider extends Provider = Provider> = TProvider & FallbackProviderConfig;
type Provider = providers.BaseProvider & {
    chains?: Chain[];
};
type WebSocketProvider = providers.WebSocketProvider & {
    chains?: Chain[];
};
type Signer = Signer$1;
type Unit = typeof units[number];
type AddEthereumChainParameter = {
    /** A 0x-prefixed hexadecimal string */
    chainId: string;
    chainName: string;
    nativeCurrency?: {
        name: string;
        /** 2-6 characters long */
        symbol: string;
        decimals: number;
    };
    rpcUrls: string[];
    blockExplorerUrls?: string[];
    /** Currently ignored. */
    iconUrls?: string[];
};
type WalletPermissionCaveat = {
    type: string;
    value: any;
};
type WalletPermission = {
    caveats: WalletPermissionCaveat[];
    date: number;
    id: string;
    invoker: `http://${string}` | `https://${string}`;
    parentCapability: 'eth_accounts' | string;
};
type WatchAssetParams = {
    /** In the future, other standards will be supported */
    type: 'ERC20';
    options: {
        /** Address of token contract */
        address: Address;
        /** Number of token decimals */
        decimals: ResolvedConfig['IntType'];
        /** String url of token logo */
        image?: string;
        /** A ticker symbol or shorthand, up to 5 characters */
        symbol: string;
    };
};
type InjectedProviderFlags = {
    isAvalanche?: true;
    isBitKeep?: true;
    isBraveWallet?: true;
    isCoinbaseWallet?: true;
    isExodus?: true;
    isFrame?: true;
    isKuCoinWallet?: true;
    isMathWallet?: true;
    isMetaMask?: true;
    isOneInchAndroidWallet?: true;
    isOneInchIOSWallet?: true;
    isOpera?: true;
    isPortal?: true;
    isTally?: true;
    isTokenPocket?: true;
    isTokenary?: true;
    isTrust?: true;
    isTrustWallet?: true;
};
type InjectedProviders = InjectedProviderFlags & {
    isMetaMask: true;
    /** Only exists in MetaMask as of 2022/04/03 */
    _events: {
        connect?: () => void;
    };
    /** Only exists in MetaMask as of 2022/04/03 */
    _state?: {
        accounts?: string[];
        initialized?: boolean;
        isConnected?: boolean;
        isPermanentlyDisconnected?: boolean;
        isUnlocked?: boolean;
    };
};
interface Ethereum extends InjectedProviders {
    on?: (...args: any[]) => void;
    removeListener?: (...args: any[]) => void;
    providers?: Ethereum[];
    /**
     * EIP-747: Add wallet_watchAsset to Provider
     * https://eips.ethereum.org/EIPS/eip-747
     */
    request(args: {
        method: 'wallet_watchAsset';
        params: WatchAssetParams;
    }): Promise<boolean>;
    /**
     * EIP-1193: Ethereum Provider JavaScript API
     * https://eips.ethereum.org/EIPS/eip-1193
     */
    request(args: {
        method: 'eth_accounts';
    }): Promise<Address[]>;
    request(args: {
        method: 'eth_chainId';
    }): Promise<string>;
    request(args: {
        method: 'eth_requestAccounts';
    }): Promise<Address[]>;
    /**
     * EIP-1474: Remote procedure call specification
     * https://eips.ethereum.org/EIPS/eip-1474
     */
    request(args: {
        method: 'web3_clientVersion';
    }): Promise<string>;
    /**
     * EIP-2255: Wallet Permissions System
     * https://eips.ethereum.org/EIPS/eip-2255
     */
    request(args: {
        method: 'wallet_requestPermissions';
        params: [{
            eth_accounts: Record<string, any>;
        }];
    }): Promise<WalletPermission[]>;
    request(args: {
        method: 'wallet_getPermissions';
    }): Promise<WalletPermission[]>;
    /**
     * EIP-3085: Wallet Add Ethereum Chain RPC Method
     * https://eips.ethereum.org/EIPS/eip-3085
     */
    request(args: {
        method: 'wallet_addEthereumChain';
        params: AddEthereumChainParameter[];
    }): Promise<null>;
    /**
     * EIP-3326: Wallet Switch Ethereum Chain RPC Method
     * https://eips.ethereum.org/EIPS/eip-3326
     */
    request(args: {
        method: 'wallet_switchEthereumChain';
        params: [{
            chainId: string;
        }];
    }): Promise<null>;
}
declare global {
    interface Window {
        ethereum?: Ethereum;
    }
}

export { Chain as C, Ethereum as E, FallbackProviderConfig as F, Hash as H, Provider as P, Signer as S, Unit as U, WebSocketProvider as W, ChainProviderFn as a, ProviderWithFallbackConfig as b, alchemyRpcUrls as c, allChains as d, chain as e, chainId as f, defaultChains as g, defaultL2Chains as h, etherscanBlockExplorers as i, infuraRpcUrls as j, arbitrum as k, arbitrumGoerli as l, foundry as m, goerli as n, hardhat as o, publicRpcUrls as p, localhost as q, mainnet as r, sepolia as s, optimism as t, units as u, optimismGoerli as v, polygon as w, polygonMumbai as x };
