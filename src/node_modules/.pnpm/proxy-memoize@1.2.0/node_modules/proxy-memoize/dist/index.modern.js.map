{"version":3,"file":"index.modern.mjs","sources":["../src/index.ts"],"sourcesContent":["import {\n  createProxy,\n  isChanged,\n  getUntracked,\n  trackMemo,\n} from 'proxy-compare';\n\ntype Affected = WeakMap<object, Set<string | number | symbol>>;\n\nconst isObject = (x: unknown): x is object => typeof x === 'object' && x !== null;\n\nconst untrack = <T>(x: T, seen: Set<T>): T => {\n  if (!isObject(x)) return x;\n  const untrackedObj = getUntracked(x);\n  if (untrackedObj !== null) {\n    trackMemo(x);\n    return untrackedObj;\n  }\n  if (!seen.has(x)) {\n    seen.add(x);\n    Object.entries(x).forEach(([k, v]) => {\n      const vv = untrack(v, seen);\n      if (!Object.is(vv, v)) x[k as keyof T] = vv;\n    });\n  }\n  return x;\n};\n\nconst touchAffected = (dst: unknown, src: unknown, affected: Affected) => {\n  if (!isObject(dst) || !isObject(src)) return;\n  const used = affected.get(getUntracked(src) || src);\n  if (!used) return;\n  used.forEach((key) => {\n    touchAffected(\n      dst[key as keyof typeof dst],\n      src[key as keyof typeof src],\n      affected,\n    );\n  });\n};\n\n// properties\nconst OBJ_PROPERTY = 'o';\nconst RESULT_PROPERTY = 'r';\nconst AFFECTED_PROPERTY = 'a';\n\n/**\n * Create a memoized function\n *\n * @example\n * import memoize from 'proxy-memoize';\n *\n * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));\n *\n * @param options\n * @param options.size - (default: 1)\n */\nconst memoize = <Obj extends object, Result>(\n  fn: (obj: Obj) => Result,\n  options?: { size?: number },\n): (obj: Obj) => Result => {\n  let memoListHead = 0;\n  const size = options?.size ?? 1;\n  type Entry = {\n    [OBJ_PROPERTY]: Obj;\n    [RESULT_PROPERTY]: Result;\n    [AFFECTED_PROPERTY]: Affected;\n  }\n  const memoList: Entry[] = [];\n  const resultCache = new WeakMap<Obj, Entry>();\n  const proxyCache = new WeakMap();\n  const memoizedFn = (obj: Obj) => {\n    const cacheKey = getUntracked(obj) || obj;\n    const cache = resultCache.get(cacheKey);\n    if (cache) {\n      touchAffected(obj, cache[OBJ_PROPERTY], cache[AFFECTED_PROPERTY]);\n      return cache[RESULT_PROPERTY];\n    }\n    for (let i = 0; i < size; i += 1) {\n      const memo = memoList[(memoListHead + i) % size];\n      if (!memo) break;\n      if (!isChanged(memo[OBJ_PROPERTY], obj, memo[AFFECTED_PROPERTY], new WeakMap())) {\n        resultCache.set(cacheKey, memo);\n        touchAffected(obj, memo[OBJ_PROPERTY], memo[AFFECTED_PROPERTY]);\n        return memo[RESULT_PROPERTY];\n      }\n    }\n    const affected: Affected = new WeakMap();\n    const proxy = createProxy(obj, affected, proxyCache);\n    const result = untrack(fn(proxy), new Set());\n    touchAffected(obj, obj, affected);\n    const entry: Entry = {\n      [OBJ_PROPERTY]: obj,\n      [RESULT_PROPERTY]: result,\n      [AFFECTED_PROPERTY]: affected,\n    };\n    memoListHead = (memoListHead - 1 + size) % size;\n    memoList[memoListHead] = entry;\n    resultCache.set(cacheKey, entry);\n    return result;\n  };\n  return memoizedFn;\n};\n\n/**\n * This is to unwrap a proxy object and return an original object.\n * It returns null if not relevant.\n *\n * [Notes]\n * This function is for debugging purpose.\n * It's not supposed to be used in production and it's subject to change.\n *\n * @example\n * import memoize, { getUntrackedObject } from 'proxy-memoize';\n *\n * const fn = memoize(obj => {\n *   console.log(getUntrackedObject(obj));\n *   return { sum: obj.a + obj.b, diff: obj.a - obj.b };\n * });\n */\nexport { getUntracked as getUntrackedObject } from 'proxy-compare';\n\n/**\n * This is to replace newProxy function in upstream library, proxy-compare.\n * Use it at your own risk.\n *\n * [Notes]\n * See related discussoin: https://github.com/dai-shi/proxy-compare/issues/40\n */\nexport { replaceNewProxy } from 'proxy-compare';\n\nexport default memoize;\n"],"names":["isObject","x","untrack","seen","untrackedObj","getUntracked","trackMemo","has","add","Object","entries","forEach","k","v","vv","is","touchAffected","dst","src","affected","used","get","key","memoize","fn","options","_options$size","memoListHead","size","memoList","resultCache","proxyCache","WeakMap","obj","cacheKey","cache","i","memo","isChanged","set","proxy","createProxy","result","Set","entry","o","r","a","memoizedFn"],"mappings":"0KASA,MAAcA,EAAIC,GAAyC,iBAANA,GAAwB,OAANA,EAE1DC,EAAG,CAAID,EAAME,KACxB,IAAKH,EAASC,GAAI,OAAAA,EAClB,MAAMG,EAAeC,EAAaJ,GAClC,OAAqB,OAAjBG,GACFE,EAAUL,GACHG,IAEJD,EAAKI,IAAIN,KACZE,EAAKK,IAAIP,GACTQ,OAAOC,QAAQT,GAAGU,QAAQ,EAAEC,EAAGC,MAC7B,MAAQC,EAAGZ,EAAQW,EAAGV,GACjBM,OAAOM,GAAGD,EAAID,KAAIZ,EAAEW,GAAgBE,EAC1C,IAEIb,IAGHe,EAAgB,CAACC,EAAcC,EAAcC,KACjD,IAAKnB,EAASiB,KAASjB,EAASkB,GAAM,OACtC,MAAUE,EAAGD,EAASE,IAAIhB,EAAaa,IAAQA,GAC1CE,GACLA,EAAKT,QAASW,IACZN,EACEC,EAAIK,GACJJ,EAAII,GACJH,EAEH,EACF,EAkBKI,EAAU,CACdC,EACAC,KAEA,IAAAC,EAAA,IAAgBC,EAAG,EACnB,MAAMC,EAAwB,OAAjBH,EAAAA,MAAAA,OAAAA,EAAAA,EAASG,MAAQF,EAAA,EAMhBG,EAAY,GACpBC,EAAc,YACJC,EAAG,IAAIC,QA+BvB,OA9BoBC,IAClB,MAAcC,EAAG7B,EAAa4B,IAAQA,EAC3BE,EAAGL,EAAYT,IAAIa,GAC9B,GAAIC,EAEF,OADAnB,EAAciB,EAAKE,EAAK,EAAgBA,EAAK,GACtCA,EAAK,EAEd,IAAK,IAAKC,EAAG,EAAGA,EAAIR,EAAMQ,GAAK,EAAG,CAChC,MAAMC,EAAOR,GAAUF,EAAeS,GAAKR,GAC3C,IAAKS,EAAM,MACX,IAAKC,EAAUD,EAAI,EAAgBJ,EAAKI,EAAI,EAAqB,IAAIL,SAGnE,OAFAF,EAAYS,IAAIL,EAAUG,GAC1BrB,EAAciB,EAAKI,EAAI,EAAgBA,EAAI,GAChCA,EAAA,CAEd,CACD,MAAMlB,EAAqB,IAA3Ba,QACMQ,EAAQC,EAAYR,EAAKd,EAAUY,GACnCW,EAASxC,EAAQsB,EAAGgB,GAAQ,IAAIG,KACtC3B,EAAciB,EAAKA,EAAKd,GACxB,MAAWyB,EAAU,CACnBC,EAAgBZ,EAChBa,EAAmBJ,EACnBK,EAAqB5B,GAKvB,OAHAQ,GAAgBA,EAAe,EAAIC,GAAQA,EAC3CC,EAASF,GAAgBiB,EACzBd,EAAYS,IAAIL,EAAUU,GAE3BF,EAEFM"}