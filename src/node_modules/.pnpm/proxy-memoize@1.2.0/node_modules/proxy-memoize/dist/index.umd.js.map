{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  createProxy,\n  isChanged,\n  getUntracked,\n  trackMemo,\n} from 'proxy-compare';\n\ntype Affected = WeakMap<object, Set<string | number | symbol>>;\n\nconst isObject = (x: unknown): x is object => typeof x === 'object' && x !== null;\n\nconst untrack = <T>(x: T, seen: Set<T>): T => {\n  if (!isObject(x)) return x;\n  const untrackedObj = getUntracked(x);\n  if (untrackedObj !== null) {\n    trackMemo(x);\n    return untrackedObj;\n  }\n  if (!seen.has(x)) {\n    seen.add(x);\n    Object.entries(x).forEach(([k, v]) => {\n      const vv = untrack(v, seen);\n      if (!Object.is(vv, v)) x[k as keyof T] = vv;\n    });\n  }\n  return x;\n};\n\nconst touchAffected = (dst: unknown, src: unknown, affected: Affected) => {\n  if (!isObject(dst) || !isObject(src)) return;\n  const used = affected.get(getUntracked(src) || src);\n  if (!used) return;\n  used.forEach((key) => {\n    touchAffected(\n      dst[key as keyof typeof dst],\n      src[key as keyof typeof src],\n      affected,\n    );\n  });\n};\n\n// properties\nconst OBJ_PROPERTY = 'o';\nconst RESULT_PROPERTY = 'r';\nconst AFFECTED_PROPERTY = 'a';\n\n/**\n * Create a memoized function\n *\n * @example\n * import memoize from 'proxy-memoize';\n *\n * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));\n *\n * @param options\n * @param options.size - (default: 1)\n */\nconst memoize = <Obj extends object, Result>(\n  fn: (obj: Obj) => Result,\n  options?: { size?: number },\n): (obj: Obj) => Result => {\n  let memoListHead = 0;\n  const size = options?.size ?? 1;\n  type Entry = {\n    [OBJ_PROPERTY]: Obj;\n    [RESULT_PROPERTY]: Result;\n    [AFFECTED_PROPERTY]: Affected;\n  }\n  const memoList: Entry[] = [];\n  const resultCache = new WeakMap<Obj, Entry>();\n  const proxyCache = new WeakMap();\n  const memoizedFn = (obj: Obj) => {\n    const cacheKey = getUntracked(obj) || obj;\n    const cache = resultCache.get(cacheKey);\n    if (cache) {\n      touchAffected(obj, cache[OBJ_PROPERTY], cache[AFFECTED_PROPERTY]);\n      return cache[RESULT_PROPERTY];\n    }\n    for (let i = 0; i < size; i += 1) {\n      const memo = memoList[(memoListHead + i) % size];\n      if (!memo) break;\n      if (!isChanged(memo[OBJ_PROPERTY], obj, memo[AFFECTED_PROPERTY], new WeakMap())) {\n        resultCache.set(cacheKey, memo);\n        touchAffected(obj, memo[OBJ_PROPERTY], memo[AFFECTED_PROPERTY]);\n        return memo[RESULT_PROPERTY];\n      }\n    }\n    const affected: Affected = new WeakMap();\n    const proxy = createProxy(obj, affected, proxyCache);\n    const result = untrack(fn(proxy), new Set());\n    touchAffected(obj, obj, affected);\n    const entry: Entry = {\n      [OBJ_PROPERTY]: obj,\n      [RESULT_PROPERTY]: result,\n      [AFFECTED_PROPERTY]: affected,\n    };\n    memoListHead = (memoListHead - 1 + size) % size;\n    memoList[memoListHead] = entry;\n    resultCache.set(cacheKey, entry);\n    return result;\n  };\n  return memoizedFn;\n};\n\n/**\n * This is to unwrap a proxy object and return an original object.\n * It returns null if not relevant.\n *\n * [Notes]\n * This function is for debugging purpose.\n * It's not supposed to be used in production and it's subject to change.\n *\n * @example\n * import memoize, { getUntrackedObject } from 'proxy-memoize';\n *\n * const fn = memoize(obj => {\n *   console.log(getUntrackedObject(obj));\n *   return { sum: obj.a + obj.b, diff: obj.a - obj.b };\n * });\n */\nexport { getUntracked as getUntrackedObject } from 'proxy-compare';\n\n/**\n * This is to replace newProxy function in upstream library, proxy-compare.\n * Use it at your own risk.\n *\n * [Notes]\n * See related discussoin: https://github.com/dai-shi/proxy-compare/issues/40\n */\nexport { replaceNewProxy } from 'proxy-compare';\n\nexport default memoize;\n"],"names":["isObject","x","untrack","seen","untrackedObj","getUntracked","trackMemo","has","add","Object","entries","forEach","_ref","k","v","vv","is","touchAffected","dst","src","affected","used","get","key","fn","options","_options$size","memoListHead","size","memoList","resultCache","WeakMap","proxyCache","obj","_entry","cacheKey","cache","i","memo","isChanged","set","proxy","createProxy","result","Set","entry","OBJ_PROPERTY","RESULT_PROPERTY","AFFECTED_PROPERTY"],"mappings":"gSASA,IAAMA,EAAW,SAACC,GAAD,MAA0C,iBAANA,GAAwB,OAANA,CAAtD,EAEXC,EAAU,SAAAA,EAAID,EAAME,GACxB,IAAKH,EAASC,GAAI,OAAOA,EACzB,IAAkBG,EAAGC,EAAYA,aAACJ,GAClC,OAAqB,OAAjBG,GACFE,EAASA,UAACL,GACHG,IAEJD,EAAKI,IAAIN,KACZE,EAAKK,IAAIP,GACTQ,OAAOC,QAAQT,GAAGU,QAAQ,SAAAC,GAAEC,IAAAA,EAAGC,EAAAA,GAAAA,EAC7BF,EAAA,GAAQG,EAAGb,EAAQY,EAAGX,GACjBM,OAAOO,GAAGD,EAAID,KAAIb,EAAEY,GAAgBE,EAC1C,IAGJd,EAAA,EAEkBgB,EAAG,SAAhBA,EAAiBC,EAAcC,EAAcC,GACjD,GAAKpB,EAASkB,IAASlB,EAASmB,GAAhC,CACA,IAAME,EAAOD,EAASE,IAAIjB,EAAYA,aAACc,IAAQA,GAC1CE,GACLA,EAAKV,QAAQ,SAACY,GACZN,EACEC,EAAIK,GACJJ,EAAII,GACJH,EAEH,EARD,CASD,oNAkBe,SACdI,EACAC,GACwB,IAAAC,EACpBC,EAAe,EACTC,EAAA,OAAAF,EAAA,MAAGD,OAAH,EAAGA,EAASG,MAAZF,EAAoB,EAMxBG,EAAoB,GACTC,EAAG,IAAIC,QACRC,EAAG,IAAID,QA+BvB,OA9BmB,SAACE,GAAY,IAAAC,EACxBC,EAAW9B,EAAAA,aAAa4B,IAAQA,EAChCG,EAAQN,EAAYR,IAAIa,GAC9B,GAAIC,EAEF,OADAnB,EAAcgB,EAAKG,EAAK,EAAgBA,EAAK,GACjCA,EAAA,EAEd,IAAK,IAAIC,EAAI,EAAGA,EAAIT,EAAMS,GAAK,EAAG,CAChC,IAAMC,EAAOT,GAAUF,EAAeU,GAAKT,GAC3C,IAAKU,EAAM,MACX,IAAKC,EAAAA,UAAUD,EAAI,EAAgBL,EAAKK,EAAI,EAAqB,IAAIP,SAGnE,OAFAD,EAAYU,IAAIL,EAAUG,GAC1BrB,EAAcgB,EAAKK,EAAI,EAAgBA,EAAI,GACpCA,EAAI,CAEd,CACD,IAAclB,EAAa,IAAIW,QACpBU,EAAGC,EAAAA,YAAYT,EAAKb,EAAUY,GAC7BW,EAAGzC,EAAQsB,EAAGiB,GAAQ,IAAZG,KACtB3B,EAAcgB,EAAKA,EAAKb,GACxB,IAAMyB,IACHC,EAAAA,CAAAA,GADQ,EACOb,EACfc,EAFQ,EAEUJ,EAClBK,EAHQ,EAGY5B,EAHvBc,GAQA,OAFAL,EADAF,GAAgBA,EAAe,EAAIC,GAAQA,GAClBiB,EACzBf,EAAYU,IAAIL,EAAUU,GACnBF,CACR,CAEF"}