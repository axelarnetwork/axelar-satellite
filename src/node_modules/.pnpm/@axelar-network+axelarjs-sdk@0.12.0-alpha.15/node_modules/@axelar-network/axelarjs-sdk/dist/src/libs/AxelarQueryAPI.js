"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxelarQueryAPI = void 0;
const utils_1 = require("ethers/lib/utils");
const assets_1 = require("../assets");
const constants_1 = require("../constants");
const services_1 = require("../services");
const contract_1 = require("./TransactionRecoveryApi/constants/contract");
const AxelarQueryClient_1 = require("./AxelarQueryClient");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const query_1 = require("@axelar-network/axelarjs-types/axelar/nexus/v1beta1/query");
const utils_2 = require("../utils");
const chains_1 = require("../chains");
const s3_1 = __importDefault(require("./TransactionRecoveryApi/constants/s3"));
const ethers_1 = require("ethers");
class AxelarQueryAPI {
    constructor(config) {
        /**
         * Initialize the query client if it hasn't been initialized yet
         */
        this.initQueryClientIfNeeded = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.axelarQueryClient) {
                this.axelarQueryClient = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient({
                    environment: this.environment,
                    axelarRpcUrl: this.axelarRpcUrl,
                });
            }
        });
        const { axelarLcdUrl, axelarRpcUrl, environment } = config;
        const links = (0, constants_1.getConfigs)(environment);
        this.axelarRpcUrl = axelarRpcUrl || links.axelarRpcUrl;
        this.axelarLcdUrl = axelarLcdUrl || links.axelarLcdUrl;
        this.axelarGMPServiceUrl = links.axelarGMPApiUrl;
        this.environment = environment;
        this.lcdApi = new services_1.RestService(this.axelarLcdUrl);
        this.rpcApi = new services_1.RestService(this.axelarRpcUrl);
        this.axelarGMPServiceApi = new services_1.RestService(this.axelarGMPServiceUrl);
        this._initializeAssets();
    }
    _initializeAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            this.allAssets = yield (0, assets_1.loadAssets)({ environment: this.environment });
        });
    }
    /**
     * Gets the fee for a chain and asset
     * example testnet query: https://axelartest-lcd.quickapi.com/axelar/nexus/v1beta1/fee?chain=ethereum&asset=uusd
     * @param chainId
     * @param assetDenom
     * @returns
     */
    getFeeForChainAndAsset(chainId, assetDenom) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([chainId], this.environment);
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.nexus.FeeInfo({
                chain: chainId,
                asset: yield this._convertAssetDenom(assetDenom),
            });
        });
    }
    /**
     * Gest the transfer fee for a given transaction
     * example testnet query: "https://axelartest-lcd.quickapi.com/axelar/nexus/v1beta1/transfer_fee?source_chain=ethereum&destination_chain=terra&amount=100000000uusd"
     * @param sourceChainId
     * @param destinationChainId
     * @param assetDenom
     * @param amountInDenom
     * @returns
     */
    getTransferFee(sourceChainId, destinationChainId, assetDenom, amountInDenom) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.nexus.TransferFee({
                sourceChain: sourceChainId,
                destinationChain: destinationChainId,
                amount: `${amountInDenom.toString()}${yield this._convertAssetDenom(assetDenom)}`,
            });
        });
    }
    /**
     * Gets the gas price for a destination chain to be paid to the gas receiver on a source chain
     * example testnet query: https://testnet.api.gmp.axelarscan.io/?method=getGasPrice&destinationChain=ethereum&sourceChain=avalanche&sourceTokenAddress=0x43F4600b552089655645f8c16D86A5a9Fa296bc3&sourceTokenSymbol=UST
     * @param sourceChainId
     * @param destinationChainId
     * @param sourceChainTokenSymbol
     * @returns
     */
    getGasInfo(sourceChainId, destinationChainId, sourceChainTokenSymbol) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            const params = new URLSearchParams({
                method: "getGasPrice",
                destinationChain: destinationChainId,
                sourceChain: sourceChainId,
                sourceTokenSymbol: sourceChainTokenSymbol,
            });
            return this.axelarGMPServiceApi.get(`?${params}`).then((resp) => resp.result);
        });
    }
    /**
     * Gets the base fee in native token wei for a given source and destination chain combination
     * @param sourceChainName
     * @param destinationChainName
     * @param sourceTokenSymbol (optional)
     * @returns base fee in native token in wei, translated into the native gas token of choice
     */
    getNativeGasBaseFee(sourceChainId, destinationChainId, sourceTokenSymbol) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            yield this.throwIfInactiveChains([sourceChainId, destinationChainId]);
            return this.axelarGMPServiceApi
                .post("", {
                method: "getFees",
                destinationChain: destinationChainId,
                sourceChain: sourceChainId,
                sourceTokenSymbol,
            })
                .then((response) => {
                const { base_fee, source_token } = response.result;
                const { decimals } = source_token;
                const baseFee = (0, utils_1.parseUnits)(base_fee.toString(), decimals).toString();
                return { baseFee, sourceToken: source_token, success: true };
            })
                .catch((error) => ({ success: false, error: error.message }));
        });
    }
    /**
     * Calculate estimated gas amount to pay for the gas receiver contract.
     * @param sourceChainId
     * @param destinationChainId
     * @param sourceChainTokenSymbol
     * @param gasLimit (Optional) An estimated gas amount required to execute `executeWithToken` function. The default value is 700000 which should be sufficient for most transactions.
     * @param gasMultiplier (Optional) A multiplier used to create a buffer above the calculated gas fee, to account for potential slippage throughout tx execution, e.g. 1.1 = 10% buffer. supports up to 3 decimal places
     * @returns
     */
    estimateGasFee(sourceChainId, destinationChainId, sourceChainTokenSymbol, gasLimit = contract_1.DEFAULT_ESTIMATED_GAS, gasMultiplier = 1.1) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            const response = yield this.getNativeGasBaseFee(sourceChainId, destinationChainId, sourceChainTokenSymbol).catch(() => undefined);
            if (!response)
                return "0";
            const { baseFee, sourceToken, success } = response;
            if (!success || !baseFee || !sourceToken)
                return "0";
            const { gas_price } = sourceToken;
            const destTxFee = (0, utils_1.parseEther)(gas_price).mul(gasLimit);
            if (gasMultiplier > 1) {
                return destTxFee
                    .add(baseFee)
                    .mul(gasMultiplier * 10000)
                    .div(10000)
                    .toString();
            }
            return destTxFee.add(baseFee).toString();
        });
    }
    /**
     * Get the denom for an asset given its symbol on a chain
     * @param symbol
     * @param chainName
     * @returns
     */
    getDenomFromSymbol(symbol, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((assetConfig) => { var _a; return ((_a = assetConfig.chain_aliases[chainName]) === null || _a === void 0 ? void 0 : _a.assetSymbol) === symbol; });
            if (!assetConfig)
                return null;
            return assetConfig === null || assetConfig === void 0 ? void 0 : assetConfig.common_key[this.environment];
        });
    }
    /**
     * Get the symbol for an asset on a given chain given its denom
     * @param denom
     * @param chainName
     * @returns
     */
    getSymbolFromDenom(denom, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((assetConfig) => assetConfig.common_key[this.environment] === denom);
            if (!assetConfig)
                return null;
            return assetConfig.chain_aliases[chainName].assetSymbol;
        });
    }
    /**
     * Get the asset config for an asset on a given chain given its denom
     * @param denom
     * @param chainName
     * @returns asset config
     */
    getAssetConfigFromDenom(denom, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((assetConfig) => assetConfig.common_key[this.environment] === denom);
            if (!assetConfig)
                return null;
            const result = assetConfig.chain_aliases[chainName];
            if (!result)
                return null;
            result.decimals = assetConfig.decimals;
            result.common_key = assetConfig.common_key[this.environment];
            return result;
        });
    }
    /**
     * Get the contract address from the chainId and the contractKey
     * @param chainId - the chainId of the chain
     * @param contractKey - the key of the contract in the config file.
     * A valid contractKey can be found here https://github.com/axelarnetwork/chains/blob/790f08350e792e27412ded6721c13ce78267fd72/testnet-config.json#L1951-L1954 e.g. ("gas_service", "deposit_service", "default_refund_collector")
     * @returns the contract address
     */
    getContractAddressFromConfig(chainId, contractKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const chains = yield (0, chains_1.loadChains)({ environment: this.environment });
            const selectedChain = chains.find((chain) => chain.id === chainId);
            if (!selectedChain)
                throw `getContractAddressFromConfig() ${chainId} not found`;
            const { chainName } = selectedChain;
            return yield (0, cross_fetch_1.default)(s3_1.default[this.environment])
                .then((res) => res.json())
                .then((body) => body.assets.network[chainId.toLowerCase()][contractKey])
                .catch(() => undefined);
        });
    }
    /**
     * Get a list of active chains.
     * @returns an array of active chains
     */
    getActiveChains() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.nexus
                .Chains({ status: query_1.ChainStatus.CHAIN_STATUS_ACTIVATED })
                .then((resp) => resp.chains);
        });
    }
    /**
     * Check if a chain is active.
     * @param chainId the chain id to check
     * @returns true if the chain is active, false otherwise
     */
    isChainActive(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getActiveChains()
                .then((chains) => chains.map((chain) => chain.toLowerCase()))
                .then((chains) => chains.includes(chainId.toLowerCase()));
        });
    }
    /**
     * Throw an error if any chain in the list is inactive.
     * @param chainIds A list of chainIds to check
     */
    throwIfInactiveChains(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(chainIds.map((chainId) => this.isChainActive(chainId)));
            for (let i = 0; i < chainIds.length; i++) {
                if (!results[i]) {
                    throw new Error(`Chain ${chainIds[i]} is not active. Please check the list of active chains using the getActiveChains() method.`);
                }
            }
        });
    }
    /**
     * Check if a chain is active.
     * @param fromChainId source chain id
     * @param toChainId destination chain id
     * @param denom denom of asset (e.g. for USDC, uusdc)
     * @param proportionOfTotalLimitPerTransfer (optional) proportion of total limit you would like to limit users, e.g. for 25% of total, use 4
     * @returns true if the chain is active, false otherwise
     */
    getTransferLimit({ fromChainId, toChainId, denom, proportionOfTotalLimitPerTransfer = 4, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromChainNexusResponse = yield this.getTransferLimitNexusQuery({
                chainId: fromChainId,
                denom,
            });
            const toChainNexusResponse = yield this.getTransferLimitNexusQuery({
                chainId: toChainId,
                denom,
            });
            try {
                let { limit: fromChainLimit } = fromChainNexusResponse;
                let { limit: toChainLimit } = toChainNexusResponse;
                if (!fromChainLimit && !toChainLimit)
                    throw new Error(`could not fetch transfer limit for transfer from ${fromChainId} to ${toChainId} for ${denom}`);
                let min;
                if (fromChainLimit && toChainLimit) {
                    const fromBigNum = ethers_1.BigNumber.from(fromChainLimit);
                    const toBigNum = ethers_1.BigNumber.from(toChainLimit);
                    min = fromBigNum.lt(toBigNum) ? fromBigNum : toBigNum;
                }
                else {
                    min = ethers_1.BigNumber.from(fromChainLimit || toChainLimit);
                }
                return min.div(proportionOfTotalLimitPerTransfer).toString();
            }
            catch (e) {
                return "";
            }
        });
    }
    getTransferLimitNexusQuery({ chainId, denom, }) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify chain params
            yield (0, utils_2.throwIfInvalidChainIds)([chainId], this.environment);
            const chains = yield (0, chains_1.loadChains)({ environment: this.environment });
            const chain = chains.find((c) => c.id === chainId);
            if (!chain)
                throw `Chain ${chainId} not found`;
            const api = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient({
                environment: this.environment,
            });
            const asset = yield this._convertAssetDenom(denom);
            try {
                // the "limit" response to the TransferRateLimit RPC query is of type Uint8Array, so need to decode it
                const res = yield api.nexus.TransferRateLimit({ chain: chainId, asset });
                const { transferRateLimit } = res;
                if (!transferRateLimit ||
                    !transferRateLimit.limit ||
                    !transferRateLimit.incoming ||
                    !transferRateLimit.outgoing)
                    throw new Error(`did not receive a valid response to ${chainId} / ${denom} transfer query`);
                const { limit, incoming, outgoing } = transferRateLimit;
                return {
                    limit: new TextDecoder("utf-8").decode(new Uint8Array(limit)),
                    outgoing: new TextDecoder("utf-8").decode(new Uint8Array(outgoing)),
                    incoming: new TextDecoder("utf-8").decode(new Uint8Array(incoming)),
                };
            }
            catch (e) {
                return { limit: "", outgoing: "", incoming: "" };
            }
        });
    }
    _convertAssetDenom(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((asset) => asset.common_key[this.environment] === denom.toLowerCase());
            if (!assetConfig)
                throw `Asset ${denom} not found`;
            return assetConfig.wrapped_erc20 ? assetConfig.wrapped_erc20 : denom;
        });
    }
}
exports.AxelarQueryAPI = AxelarQueryAPI;
//# sourceMappingURL=AxelarQueryAPI.js.map