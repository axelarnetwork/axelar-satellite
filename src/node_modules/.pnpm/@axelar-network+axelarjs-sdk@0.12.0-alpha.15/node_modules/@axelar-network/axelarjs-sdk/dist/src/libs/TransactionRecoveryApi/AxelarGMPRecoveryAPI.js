"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxelarGMPRecoveryAPI = void 0;
const types_1 = require("../types");
const AxelarRecoveryApi_1 = require("./AxelarRecoveryApi");
const EVMClient_1 = __importDefault(require("./client/EVMClient"));
const IAxelarExecutable_1 = __importDefault(require("../abi/IAxelarExecutable"));
const ethers_1 = require("ethers");
const contract_1 = require("./constants/contract");
const AxelarQueryAPI_1 = require("../AxelarQueryAPI");
const chain_1 = __importDefault(require("./constants/chain"));
const contractEventHelper_1 = require("./helpers/contractEventHelper");
const erc20Abi_json_1 = __importDefault(require("../abi/erc20Abi.json"));
const AxelarGateway_1 = require("../AxelarGateway");
const providerHelper_1 = require("./helpers/providerHelper");
const error_1 = require("./constants/error");
const helpers_1 = require("./helpers");
const utils_1 = require("../../utils");
const utils_2 = require("ethers/lib/utils");
class AxelarGMPRecoveryAPI extends AxelarRecoveryApi_1.AxelarRecoveryApi {
    constructor(config) {
        super(config);
        this.axelarQueryApi = new AxelarQueryAPI_1.AxelarQueryAPI({
            environment: config.environment,
            axelarRpcUrl: this.axelarRpcUrl,
            axelarLcdUrl: this.axelarLcdUrl,
        });
    }
    saveGMP(sourceTransactionHash, relayerAddress, transactionHash, error) {
        const _super = Object.create(null, {
            getAxelarGMPApiUrl: { get: () => super.getAxelarGMPApiUrl }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.execPost(_super.getAxelarGMPApiUrl, "", {
                method: "saveGMP",
                sourceTransactionHash,
                transactionHash,
                relayerAddress,
                error,
            });
        });
    }
    manualRelayToDestChain(txHash, evmWalletDetails) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const _evmWalletDetails = evmWalletDetails || { useWindowEthereum: true };
            const { callTx, status } = yield this.queryTransactionStatus(txHash);
            let confirmTx;
            let createPendingTransferTx;
            let signCommandTx;
            const errorResponse = (error, errorDetails) => ({
                success: false,
                error: errorDetails || error,
                confirmTx,
                createPendingTransferTx,
                signCommandTx,
            });
            if (status === AxelarRecoveryApi_1.GMPStatus.CANNOT_FETCH_STATUS)
                return errorResponse(types_1.ApproveGatewayError.FETCHING_STATUS_FAILED);
            if (status === AxelarRecoveryApi_1.GMPStatus.DEST_EXECUTED)
                return errorResponse(types_1.ApproveGatewayError.ALREADY_EXECUTED);
            if (status === AxelarRecoveryApi_1.GMPStatus.DEST_GATEWAY_APPROVED)
                return errorResponse(types_1.ApproveGatewayError.ALREADY_APPROVED);
            const srcChain = callTx.chain;
            const destChain = callTx.returnValues.destinationChain;
            try {
                confirmTx = yield this.confirmGatewayTx(txHash, srcChain);
                yield (0, utils_1.sleep)(2);
                createPendingTransferTx = yield this.createPendingTransfers(destChain);
                yield (0, utils_1.sleep)(2);
                signCommandTx = yield this.signCommands(destChain);
                const signEvent = (_b = (_a = signCommandTx.rawLog[0]) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.find((event) => event.type === "sign");
                if (!signEvent)
                    return errorResponse(types_1.ApproveGatewayError.SIGN_COMMAND_FAILED);
                yield (0, utils_1.sleep)(2);
                const batchedCommandId = (_c = signEvent.attributes.find((attr) => attr.key === "batchedCommandId")) === null || _c === void 0 ? void 0 : _c.value;
                const batchedCommand = yield (0, utils_1.asyncRetry)(() => this.queryBatchedCommands(destChain, batchedCommandId), (res) => { var _a; return !!res && ((_a = res.executeData) === null || _a === void 0 ? void 0 : _a.length) > 0; });
                if (!batchedCommand)
                    return errorResponse(types_1.ApproveGatewayError.ERROR_BATCHED_COMMAND);
                yield (0, utils_1.sleep)(2);
                const approveTx = yield this.sendApproveTx(destChain, batchedCommand.executeData, _evmWalletDetails);
                return {
                    success: true,
                    confirmTx,
                    createPendingTransferTx,
                    signCommandTx,
                    approveTx,
                };
            }
            catch (e) {
                if (e.message.includes("account sequence mismatch")) {
                    return errorResponse(types_1.ApproveGatewayError.ERROR_ACCOUNT_SEQUENCE_MISMATCH);
                }
                return errorResponse(types_1.ApproveGatewayError.ERROR_UNKNOWN, e.message);
            }
        });
    }
    /**
     * Check if given transaction is already executed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already executed
     */
    isExecuted(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txStatus = yield this.queryTransactionStatus(txHash).catch(() => undefined);
            return (txStatus === null || txStatus === void 0 ? void 0 : txStatus.status) === AxelarRecoveryApi_1.GMPStatus.DEST_EXECUTED;
        });
    }
    /**
     * Calculate the gas fee in native token for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateNativeGasFee(txHash, sourceChain, destinationChain, gasTokenSymbol, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([sourceChain, destinationChain], this.environment);
            const provider = options.provider || (0, providerHelper_1.getDefaultProvider)(sourceChain, this.environment);
            const receipt = yield provider.getTransactionReceipt(txHash);
            const paidGasFee = (0, contractEventHelper_1.getNativeGasAmountFromTxReceipt)(receipt) || "0";
            return this.subtractGasFee(sourceChain, destinationChain, gasTokenSymbol, paidGasFee, options);
        });
    }
    /**
     * Calculate the gas fee in an ERC-20 tokens for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateGasFee(txHash, sourceChain, destinationChain, gasTokenSymbol, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([sourceChain, destinationChain], this.environment);
            const provider = options.provider || (0, providerHelper_1.getDefaultProvider)(sourceChain, this.environment);
            const receipt = yield provider.getTransactionReceipt(txHash);
            const paidGasFee = (0, contractEventHelper_1.getGasAmountFromTxReceipt)(receipt) || "0";
            return this.subtractGasFee(sourceChain, destinationChain, gasTokenSymbol, paidGasFee, options);
        });
    }
    /**
     * Pay native token as gas fee for the given transaction hash.
     * If the transaction details is not valid, it will return an error with reason.
     * @param chain - source chain
     * @param txHash - transaction hash
     * @param options - options
     * @returns
     */
    addNativeGas(chain, txHash, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const evmWalletDetails = (options === null || options === void 0 ? void 0 : options.evmWalletDetails) || { useWindowEthereum: true };
            const signer = this.getSigner(chain, evmWalletDetails);
            const signerAddress = yield signer.getAddress();
            const gasReceiverAddress = yield this.axelarQueryApi.getContractAddressFromConfig(chain, "gas_service");
            const nativeGasTokenSymbol = contract_1.NATIVE_GAS_TOKEN_SYMBOL[chain];
            const receipt = yield signer.provider.getTransactionReceipt(txHash);
            if (!receipt)
                return (0, error_1.InvalidTransactionError)(chain);
            const destinationChain = (0, contractEventHelper_1.getDestinationChainFromTxReceipt)(receipt);
            const logIndex = (0, contractEventHelper_1.getLogIndexFromTxReceipt)(receipt);
            // Check if given txHash is valid
            if (!destinationChain)
                return (0, error_1.NotGMPTransactionError)();
            // Check if the transaction status is already executed or not.
            const _isExecuted = yield this.isExecuted(txHash);
            if (_isExecuted)
                return (0, error_1.AlreadyExecutedError)();
            let gasFeeToAdd = options === null || options === void 0 ? void 0 : options.amount;
            if (!gasFeeToAdd) {
                gasFeeToAdd = yield this.calculateNativeGasFee(txHash, chain, destinationChain, nativeGasTokenSymbol, { estimatedGas: options === null || options === void 0 ? void 0 : options.estimatedGasUsed, provider: evmWalletDetails.provider }).catch(() => undefined);
            }
            // Check if gas price is queried successfully.
            if (!gasFeeToAdd)
                return (0, error_1.GasPriceAPIError)();
            // Check if gas fee is not already sufficiently paid.
            if (gasFeeToAdd === "0")
                return (0, error_1.AlreadyPaidGasFeeError)();
            const refundAddress = (options === null || options === void 0 ? void 0 : options.refundAddress) || signerAddress;
            const contract = new ethers_1.ethers.Contract(gasReceiverAddress, [
                "function addNativeGas(bytes32 txHash,uint256 logIndex,address refundAddress) external payable",
            ], signer);
            return contract
                .addNativeGas(txHash, logIndex, refundAddress, {
                value: gasFeeToAdd,
            })
                .then((tx) => tx.wait())
                .then((tx) => ({
                success: true,
                transaction: tx,
            }))
                .catch(error_1.ContractCallError);
        });
    }
    /**
     * Pay ERC20 token as gas fee for the given transaction hash.
     * If the transaction details or `gasTokenAddress` is not valid, it will return an error with reason.
     *
     * @param chain EvmChain - The source chain of the transaction hash.
     * @param txHash string - The transaction hash.
     * @param gasTokenAddress string - The address of the ERC20 token to pay as gas fee.
     * @param options AddGasOptions - The options to pay gas fee.
     * @returns
     */
    addGas(chain, txHash, gasTokenAddress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const evmWalletDetails = (options === null || options === void 0 ? void 0 : options.evmWalletDetails) || { useWindowEthereum: true };
            const signer = this.getSigner(chain, evmWalletDetails);
            const signerAddress = yield signer.getAddress();
            const gasReceiverAddress = yield this.axelarQueryApi.getContractAddressFromConfig(chain, "gas_service");
            const gasTokenContract = new ethers_1.ethers.Contract(gasTokenAddress, erc20Abi_json_1.default, signer.provider);
            const gasTokenSymbol = yield gasTokenContract.symbol().catch(() => undefined);
            // Check if given `gasTokenAddress` exists
            if (!gasTokenSymbol)
                return (0, error_1.InvalidGasTokenError)();
            const axelarGateway = AxelarGateway_1.AxelarGateway.create(this.environment, chain, signer.provider);
            const gatewayGasTokenAddress = yield axelarGateway.getTokenAddress(gasTokenSymbol);
            // Check if given `gasTokenAddress` is supported by Axelar.
            if (gatewayGasTokenAddress === ethers_1.ethers.constants.AddressZero)
                return (0, error_1.UnsupportedGasTokenError)(gasTokenAddress);
            const receipt = yield signer.provider.getTransactionReceipt(txHash);
            // Check if transaction exists
            if (!receipt)
                return (0, error_1.InvalidTransactionError)(chain);
            const destinationChain = (0, contractEventHelper_1.getDestinationChainFromTxReceipt)(receipt);
            const logIndex = (0, contractEventHelper_1.getLogIndexFromTxReceipt)(receipt);
            // Check if given txHash is valid
            if (!destinationChain)
                return (0, error_1.NotGMPTransactionError)();
            // Check if the transaction status is already executed or not.
            const _isExecuted = yield this.isExecuted(txHash);
            if (_isExecuted)
                return (0, error_1.AlreadyExecutedError)();
            let gasFeeToAdd = options === null || options === void 0 ? void 0 : options.amount;
            if (!gasFeeToAdd) {
                gasFeeToAdd = yield this.calculateGasFee(txHash, chain, destinationChain, gasTokenSymbol, {
                    estimatedGas: options === null || options === void 0 ? void 0 : options.estimatedGasUsed,
                    provider: evmWalletDetails.provider,
                }).catch(() => undefined);
            }
            // Check if gas price is queried successfully.
            if (!gasFeeToAdd)
                return (0, error_1.GasPriceAPIError)();
            // Check if gas fee is not already sufficiently paid.
            if (gasFeeToAdd === "0")
                return (0, error_1.AlreadyPaidGasFeeError)();
            const refundAddress = (options === null || options === void 0 ? void 0 : options.refundAddress) || signerAddress;
            const contract = new ethers_1.ethers.Contract(gasReceiverAddress, new utils_2.Interface([
                "function addGas(bytes32 txHash,uint256 txIndex,address gasToken,uint256 gasFeeAmount,address refundAddress) external",
            ]), signer);
            return contract
                .addGas(txHash, logIndex, gasTokenAddress, gasFeeToAdd, refundAddress)
                .then((tx) => tx.wait())
                .then((tx) => ({
                success: true,
                transaction: tx,
            }))
                .catch(error_1.ContractCallError);
        });
    }
    /**
     * Execute a transaction on the destination chain associated with given `srcTxHash`.
     * @param srcTxHash - The transaction hash on the source chain.
     * @param srcTxLogIndex - The log index of the transaction on the source chain.
     * @param evmWalletDetails - The wallet details to use for executing the transaction.
     * @returns The result of executing the transaction.
     */
    execute(srcTxHash, srcTxLogIndex, evmWalletDetails) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryExecuteParams(srcTxHash, srcTxLogIndex).catch(() => undefined);
            // Couldn't query the transaction details
            if (!response)
                return (0, error_1.GMPQueryError)();
            // Already executed
            if ((response === null || response === void 0 ? void 0 : response.status) === AxelarRecoveryApi_1.GMPStatus.DEST_EXECUTED)
                return (0, error_1.AlreadyExecutedError)();
            // Not Approved yet
            if ((response === null || response === void 0 ? void 0 : response.status) !== AxelarRecoveryApi_1.GMPStatus.DEST_GATEWAY_APPROVED)
                return (0, error_1.NotApprovedError)();
            const executeParams = response.data;
            const { destinationChain, destinationContractAddress } = executeParams;
            const signer = this.getSigner(destinationChain, evmWalletDetails);
            const contract = new ethers_1.ethers.Contract(destinationContractAddress, IAxelarExecutable_1.default.abi, signer);
            const txResult = yield (0, helpers_1.callExecute)(executeParams, contract)
                .then((tx) => {
                const { commandId, sourceChain, sourceAddress, payload, symbol, amount, isContractCallWithToken, } = executeParams;
                const functionName = isContractCallWithToken ? "executeWithToken" : "execute";
                return {
                    success: true,
                    transaction: tx,
                    data: {
                        functionName,
                        args: {
                            commandId,
                            sourceChain,
                            sourceAddress,
                            payload,
                            symbol,
                            amount,
                        },
                    },
                };
            })
                .catch((e) => {
                if (e.message === helpers_1.CALL_EXECUTE_ERROR.INSUFFICIENT_FUNDS) {
                    return (0, error_1.InsufficientFundsError)(executeParams);
                }
                else if (e.message === helpers_1.CALL_EXECUTE_ERROR.REVERT) {
                    return (0, error_1.ExecutionRevertedError)(executeParams);
                }
                else {
                    // should not happen
                    return (0, error_1.ContractCallError)(e);
                }
            });
            // Submit execute data to axelarscan if the contract execution is success.
            const signerAddress = yield signer.getAddress();
            const executeTxHash = (_a = txResult.transaction) === null || _a === void 0 ? void 0 : _a.transactionHash;
            if (executeTxHash) {
                yield this.saveGMP(srcTxHash, signerAddress, executeTxHash).catch(() => undefined);
            }
            else {
                yield this.saveGMP(srcTxHash, signerAddress, "", txResult.error).catch(() => undefined);
            }
            return txResult;
        });
    }
    subtractGasFee(sourceChain, destinationChain, gasTokenSymbol, paidGasFee, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const totalGasFee = yield this.axelarQueryApi.estimateGasFee(sourceChain, destinationChain, gasTokenSymbol, options.estimatedGas);
            const topupGasAmount = ethers_1.ethers.BigNumber.from(totalGasFee).sub(paidGasFee);
            return topupGasAmount.gt(0) ? topupGasAmount.toString() : "0";
        });
    }
    getSigner(chain, evmWalletDetails = { useWindowEthereum: true }) {
        const { rpcMap, networkInfo } = chain_1.default[this.environment];
        const evmClientConfig = {
            rpcUrl: rpcMap[chain],
            networkOptions: networkInfo[chain],
            evmWalletDetails,
        };
        const evmClient = new EVMClient_1.default(evmClientConfig);
        return evmClient.getSigner();
    }
}
exports.AxelarGMPRecoveryAPI = AxelarGMPRecoveryAPI;
//# sourceMappingURL=AxelarGMPRecoveryAPI.js.map