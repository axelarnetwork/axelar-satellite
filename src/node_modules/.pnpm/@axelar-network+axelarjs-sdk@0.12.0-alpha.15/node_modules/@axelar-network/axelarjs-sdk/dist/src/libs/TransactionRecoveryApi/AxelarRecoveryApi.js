"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxelarRecoveryApi = exports.GasPaidStatus = exports.GMPStatus = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const chains_1 = require("../../chains");
const constants_1 = require("../../constants");
const cosmos_1 = require("./client/helpers/cosmos");
const AxelarQueryClient_1 = require("../AxelarQueryClient");
const EVMClient_1 = __importDefault(require("./client/EVMClient"));
const chain_1 = __importDefault(require("./constants/chain"));
const ethers_1 = require("ethers");
const utils_1 = require("../../utils");
var GMPStatus;
(function (GMPStatus) {
    GMPStatus["SRC_GATEWAY_CALLED"] = "source_gateway_called";
    GMPStatus["DEST_GATEWAY_APPROVED"] = "destination_gateway_approved";
    GMPStatus["DEST_EXECUTED"] = "destination_executed";
    GMPStatus["DEST_EXECUTE_ERROR"] = "error";
    GMPStatus["DEST_EXECUTING"] = "executing";
    GMPStatus["APPROVING"] = "approving";
    GMPStatus["FORECALLED"] = "forecalled";
    GMPStatus["FORECALLED_WITHOUT_GAS_PAID"] = "forecalled_without_gas_paid";
    GMPStatus["NOT_EXECUTED"] = "not_executed";
    GMPStatus["NOT_EXECUTED_WITHOUT_GAS_PAID"] = "not_executed_without_gas_paid";
    GMPStatus["INSUFFICIENT_FEE"] = "insufficient_fee";
    GMPStatus["UNKNOWN_ERROR"] = "unknown_error";
    GMPStatus["CANNOT_FETCH_STATUS"] = "cannot_fetch_status";
})(GMPStatus = exports.GMPStatus || (exports.GMPStatus = {}));
var GasPaidStatus;
(function (GasPaidStatus) {
    GasPaidStatus["GAS_UNPAID"] = "gas_unpaid";
    GasPaidStatus["GAS_PAID"] = "gas_paid";
    GasPaidStatus["GAS_PAID_NOT_ENOUGH_GAS"] = "gas_paid_not_enough_gas";
    GasPaidStatus["GAS_PAID_ENOUGH_GAS"] = "gas_paid_enough_gas";
})(GasPaidStatus = exports.GasPaidStatus || (exports.GasPaidStatus = {}));
class AxelarRecoveryApi {
    constructor(config) {
        this.axelarQuerySvc = null;
        const { environment } = config;
        const links = (0, constants_1.getConfigs)(environment);
        this.axelarGMPApiUrl = links.axelarGMPApiUrl;
        this.recoveryApiUrl = links.recoveryApiUrl;
        this.axelarRpcUrl = config.axelarRpcUrl || links.axelarRpcUrl;
        this.axelarLcdUrl = config.axelarLcdUrl || links.axelarLcdUrl;
        this.environment = environment;
        this.config = config;
    }
    fetchGMPTransaction(txHash, txLogIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.execGet(this.axelarGMPApiUrl, {
                method: "searchGMP",
                txHash,
                txLogIndex,
            })
                .then((data) => data.find((gmpTx) => gmpTx.id.indexOf(txHash) > -1))
                .catch(() => undefined);
        });
    }
    parseGMPStatus(response) {
        const { error, status } = response;
        if (status === "error" && error)
            return GMPStatus.DEST_EXECUTE_ERROR;
        else if (status === "executed")
            return GMPStatus.DEST_EXECUTED;
        else if (status === "approved")
            return GMPStatus.DEST_GATEWAY_APPROVED;
        else if (status === "called")
            return GMPStatus.SRC_GATEWAY_CALLED;
        else if (status === "executing")
            return GMPStatus.DEST_EXECUTING;
        else {
            return status;
        }
    }
    parseGMPError(response) {
        if (response.error) {
            return {
                message: response.error.error.message,
                txHash: response.error.error.transactionHash,
                chain: response.error.chain,
            };
        }
        else if (response.is_insufficient_fee) {
            return {
                message: "Insufficient fee",
                txHash: response.call.transaction.hash,
                chain: response.call.chain,
            };
        }
    }
    queryTransactionStatus(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txDetails = yield this.fetchGMPTransaction(txHash);
            if (!txDetails)
                return { status: GMPStatus.CANNOT_FETCH_STATUS };
            const { call, gas_status, gas_paid, executed, approved, callback } = txDetails;
            const gasPaidInfo = {
                status: gas_status,
                details: gas_paid,
            };
            // Note: Currently, the GMP API doesn't always return the `total` field in the `time_spent` object
            // This is a temporary fix to ensure that the `total` field is always present
            // TODO: Remove this once the API is fixed
            const timeSpent = txDetails.time_spent;
            if (timeSpent) {
                timeSpent.total =
                    timeSpent.total ||
                        Object.values(timeSpent).reduce((accumulator, value) => accumulator + value, 0);
            }
            return {
                status: this.parseGMPStatus(txDetails),
                error: this.parseGMPError(txDetails),
                timeSpent,
                gasPaidInfo,
                callTx: call,
                executed,
                approved,
                callback,
            };
        });
    }
    queryExecuteParams(txHash, txLogIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.fetchGMPTransaction(txHash, txLogIndex);
            if (!data)
                return;
            // Return if approve tx doesn't not exist
            const approvalTx = data.approved;
            if (!(approvalTx === null || approvalTx === void 0 ? void 0 : approvalTx.transactionHash)) {
                return {
                    status: GMPStatus.SRC_GATEWAY_CALLED,
                };
            }
            // Return if it's already executed
            const executeTx = data.executed;
            if (executeTx === null || executeTx === void 0 ? void 0 : executeTx.transactionHash) {
                return {
                    status: GMPStatus.DEST_EXECUTED,
                };
            }
            const callTx = data.call;
            return {
                status: GMPStatus.DEST_GATEWAY_APPROVED,
                data: {
                    commandId: approvalTx.returnValues.commandId,
                    destinationChain: approvalTx.chain.toLowerCase(),
                    destinationContractAddress: callTx.returnValues.destinationContractAddress,
                    isContractCallWithToken: callTx.event === "ContractCallWithToken",
                    payload: callTx.returnValues.payload,
                    sourceAddress: approvalTx.returnValues.sourceAddress,
                    sourceChain: approvalTx.returnValues.sourceChain,
                    symbol: approvalTx.returnValues.symbol,
                    amount: approvalTx.returnValues.amount &&
                        ethers_1.BigNumber.from(approvalTx.returnValues.amount).toString(),
                },
            };
        });
    }
    getChainInfo(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = (yield (0, chains_1.loadChains)({
                environment: this.environment,
            })).find((chainInfo) => chainInfo.id.toLowerCase() === chainId.toLowerCase());
            if (!chainInfo)
                throw new Error("cannot find chain" + chainId);
            return chainInfo;
        });
    }
    confirmGatewayTx(txHash, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { module, chainIdentifier } = yield this.getChainInfo(chainName);
            const txBytes = yield this.execRecoveryUrlFetch("/confirm_gateway_tx", {
                txHash,
                module,
                chain: chainIdentifier[this.environment],
            });
            return (0, cosmos_1.broadcastCosmosTxBytes)(txBytes, this.axelarRpcUrl);
        });
    }
    createPendingTransfers(chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { module, chainIdentifier } = yield this.getChainInfo(chainName);
            const txBytes = yield this.execRecoveryUrlFetch("/create_pending_transfers", {
                chain: chainIdentifier[this.environment],
                module,
            });
            return (0, cosmos_1.broadcastCosmosTxBytes)(txBytes, this.axelarRpcUrl);
        });
    }
    executePendingTransfers(chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { module, chainIdentifier } = yield this.getChainInfo(chainName);
            const txBytes = yield this.execRecoveryUrlFetch("/execute_pending_transfers", {
                chain: chainIdentifier[this.environment],
                module,
            });
            return (0, cosmos_1.broadcastCosmosTxBytes)(txBytes, this.axelarRpcUrl);
        });
    }
    signCommands(chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { module, chainIdentifier } = yield this.getChainInfo(chainName);
            const txBytes = yield this.execRecoveryUrlFetch("/sign_commands", {
                chain: chainIdentifier[this.environment],
                module,
            });
            return (0, cosmos_1.broadcastCosmosTxBytes)(txBytes, this.axelarRpcUrl);
        });
    }
    queryBatchedCommands(chainId, batchCommandId = "") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.axelarQuerySvc)
                this.axelarQuerySvc = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient(this.config);
            yield (0, utils_1.throwIfInvalidChainIds)([chainId], this.environment);
            return this.axelarQuerySvc.evm.BatchedCommands({ chain: chainId, id: batchCommandId });
        });
    }
    queryGatewayAddress({ chain }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.axelarQuerySvc)
                this.axelarQuerySvc = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient(this.config);
            yield (0, utils_1.throwIfInvalidChainIds)([chain], this.environment);
            return this.axelarQuerySvc.evm.GatewayAddress({ chain });
        });
    }
    getSignedTxAndBroadcast(chain, data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([chain], this.environment);
            const gatewayInfo = yield this.queryGatewayAddress({ chain });
            const evmClient = new EVMClient_1.default({
                rpcUrl: chain_1.default[this.environment].rpcMap[chain],
                evmWalletDetails: { useWindowEthereum: true },
            });
            const txRequest = evmClient.buildUnsignedTx(gatewayInfo.address, { data });
            const signedTx = yield this.execRecoveryUrlFetch("/sign_evm_tx", {
                chain,
                gatewayAddress: gatewayInfo.address,
                txRequest,
            });
            const tx = yield evmClient.broadcastSignedTx(signedTx);
            tx.wait(1);
            return tx;
        });
    }
    sendApproveTx(chain, data, evmWalletDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([chain], this.environment);
            const gatewayInfo = yield this.queryGatewayAddress({ chain });
            const evmClient = new EVMClient_1.default({
                rpcUrl: chain_1.default[this.environment].rpcMap[chain],
                evmWalletDetails,
            });
            const txRequest = evmClient.buildUnsignedTx(gatewayInfo.address, { data });
            return this.execRecoveryUrlFetch("/send_evm_tx", {
                chain,
                gatewayAddress: gatewayInfo.address,
                txRequest,
            });
        });
    }
    broadcastEvmTx(chain, data, evmWalletDetails = { useWindowEthereum: true }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([chain], this.environment);
            const gatewayInfo = yield this.queryGatewayAddress({ chain });
            const evmClient = new EVMClient_1.default({
                rpcUrl: chain_1.default[this.environment].rpcMap[chain],
                evmWalletDetails,
            });
            return evmClient.broadcastToGateway(gatewayInfo.address, { data });
        });
    }
    execRecoveryUrlFetch(endpoint, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.execPost(this.recoveryApiUrl, endpoint, params);
        });
    }
    execPost(base, endpoint, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, cross_fetch_1.default)(base + endpoint, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(params),
            })
                .then((res) => res.json())
                .then((res) => res.data);
        });
    }
    execGet(base, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, cross_fetch_1.default)(base + "?" + new URLSearchParams(params).toString(), {
                method: "GET",
                headers: { "Content-Type": "application/json" },
                cache: "no-store",
            })
                .then((res) => res.json())
                .then((res) => res.data);
        });
    }
    get getAxelarGMPApiUrl() {
        return this.axelarGMPApiUrl;
    }
}
exports.AxelarRecoveryApi = AxelarRecoveryApi;
//# sourceMappingURL=AxelarRecoveryApi.js.map